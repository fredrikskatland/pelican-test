# Exploring the Plan and Building Law Chatbot

Date: 2023-09-06

Category: Blog

## Introduction

In this blog post, we will explore a Streamlit application that creates a chatbot for answering questions about the Plan and Building Law. The chatbot uses OpenAI's GPT-4 model and a document retriever to provide responses. The document retriever is built using the Chroma vector store, which is created from the documents of the Plan and Building Law. The application also provides options to configure the chatbot's behavior, such as the model to use, the temperature setting, the system message, the type of retriever, and the granularity of the documents.

In the following sections, we will delve into the details of how this application is implemented.
## Setting up the Environment

The application starts by importing the necessary libraries. These include Streamlit for creating the web application, OpenAIEmbeddings for generating embeddings of the documents, and various classes from the langchain library for creating the chatbot and the document retriever.

The application then sets up the Streamlit page configuration and creates a client object. It also defines two system messages that can be used by the chatbot to introduce itself to the user.

Finally, it sets up a flag for running the application locally and a list of starter messages that the chatbot can use to initiate the conversation.
## Configuring the Retriever

The document retriever is a crucial component of the chatbot. It is responsible for retrieving relevant documents based on the user's input. The application provides a function, `configure_retriever`, to set up the retriever.

The function first checks if a Chroma vector store already exists on disk. If it does not, it creates a new one from the documents of the Plan and Building Law. The documents are loaded from a directory, and their embeddings are generated using the OpenAIEmbeddings class. The Chroma vector store is then created from these documents and their embeddings, and it is persisted to disk for future use.

The function then creates a retriever from the Chroma vector store. If the 'MultiQueryRetriever' option is selected, it also creates a MultiQueryRetriever that uses the language model to generate multiple queries for each user input.

The function returns the configured retriever, which can be used by the chatbot to retrieve relevant documents based on the user's input.
## Reloading the Language Model

The language model is another crucial component of the chatbot. It is responsible for generating responses to the user's input. The application provides a function, `reload_llm`, to reload the language model.

The function first creates a new instance of the ChatOpenAI class with the selected model and temperature setting. It then creates a prompt for the language model using the selected system message and a placeholder for the chat history.

The function also creates a retriever tool from the previously configured retriever. This tool is added to the list of tools that the language model can use to generate responses.

Finally, the function creates an instance of the OpenAIFunctionsAgent class with the language model, the prompt, and the tools. It also creates an instance of the AgentExecutor class to execute the agent and an instance of the AgentTokenBufferMemory class to store the chat history.

The function returns the agent executor, the memory, and the language model. These can be used by the chatbot to generate responses to the user's input and to manage the chat history.
## Running the Chatbot

With the environment set up, the retriever configured, and the language model reloaded, the chatbot is ready to run.

The application provides a sidebar form for the user to select the model, the temperature setting, the system message, the type of retriever, and the granularity of the documents. When the user submits the form, the language model is reloaded with the selected settings.

The application then displays a chat interface for the user to interact with the chatbot. The user can enter a message, and the chatbot will respond with a message generated by the language model. The chat history is stored in the session state and can be cleared by the user.

The application also provides a button to reload the language model with the current settings. This can be useful if the user wants to change the behavior of the chatbot during the conversation.

In conclusion, this application provides a powerful and flexible chatbot for answering questions about the Plan and Building Law. It demonstrates the use of OpenAI's GPT-4 model, a document retriever, and a Streamlit interface to create an interactive and informative chatbot.